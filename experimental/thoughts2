compiling to a VM language with pico

fact[num] = ({if n:num < 2 then acc:num else $(n-1, acc * n)}(,1))

goes to:

fact$1:
   push arg 0
   push 2
   lt
   elsegoto fact$1$else
   push arg 1
   return
fact$1$else:
   push arg 0
   push 1
   sub
   push arg 1
   push arg 0
   mult
   pop arg 1
   pop arg 0
   goto fact$1
fact:
   push arg 0
   push 1
   call fact$1
   return

assignment with brackets means new namespace "fact". 
   push empty symtable on the stack
   eval ({if n:num < 2 then acc:num else $(n-1, acc * n)}(,1))
      eval call
         eval args
            eval _
               current arg count is 0
                  -> push arg 0
            eval 1
               -> push 1
         eval {if n:num < 2 then acc:num else $(n-1, acc * n)}
            lambda, means new namespace with $1 added = "fact$1"
               push empty symtable on the stack
               eval if statement
                  eval condition n:num < 2
                        eval left n:num
                           lookup n, not found, unbound and count = 0, so arg 0
                              -> push arg 0
                        eval right 2
                           -> push 2
                        eval <
                           -> lt
                     add elsegoto
                        current namespace is "fact$1"
                           -> elsegoto fact$1$else
                  eval if_true acc:num
                     eval acc:num
                        lookup acc, not found, unbound and count = 1, so arg 1
                           -> push arg 1
                     add return
                        -> return
                  eval if_false $(n-1, acc * n)
                     add label for else
                        -> fact$1$else:
                     eval args
                        eval n-1
                           eval left n
                              lookup n, set to arg 0
                                 -> push arg0
                           eval right 1
                              -> push 1
                           eval -
                              -> sub
                        eval acc * n
                           eval left acc
                              lookup acc: arg 1
                                 -> push arg 1
                           eval right n
                              lookup n: arg 0
                                 -> push arg 0
                           eval *
                              -> mult
                     eval $
                        recurse to namespace parent = "fact$1"
                           -> call fact$1
                     add return
                        -> return // not tail recursing just yet