fact[num] = {
   fact'[n:num, acc:num] = {
      if n < 2 then acc else fact'(n-1, acc * n); 
   },
   fact'(,1)
}

fact[n:num] = {{if n:num < 2 then acc:num else $(n-1, acc * n)}(n,1)}

// imagine we have a map type and a lookup function

my_map[num, num] = empty_map(num, num),
lookup_in_my_map[num] = lookup(, my_map)


hmmm what about a purely functional formulation of a list? Problem is we
need algebraic types first.

// defines the type list and whatever initial functions can produce lists
type list = empty or (a,list)

// pattern matching now works
(++)[l1:list, l2:list] = (when l1 is empty, l2. when l1 is (a, l), (a, l ++ l2).)

type map[ord, a] = empty or (ord, a, map, map)

insert[m:map, k:ord, v:a] = (
   when m is empty, (k, v, empty, empty).
   when m is (k', v', l, r), 
      if k < k' then $(l, k, v) else $(r, k, v).
)

lookup[m:map, k:ord] = (
   when m is empty, none.
   when m is (k', v, l, r),
      if k < k' then $(l, k) else
      if k > k' then $(r, k) else
      some(v).
)

from_list[l:list] = (
   when l is empty, map.empty.
   when l is ((a,b), l'), insert($(l'), (a,b)).
)

In functional C!
In functional C, all variables declared with @type take and return pointers by
default. If a parameter is not a pointer, a # is used.
@type Int {Int(int#);}; // takes an int, returns an Int pointer
@type Any {Any(void);}; // takes a void *, returns an Any ptr
@type List {Empty; Cons(Any, List);}; // Cons takes an Any ptr and a List ptr
List concat(List l1, List l2) {
   switch (l1) {
      case Empty: return l2;
      case Cons(Any a, List l): return Cons(a, concat(l, l2));
   }
}

@type Map {Leaf; Branch(Int, Any, Map, Map);}