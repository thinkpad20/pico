Terminals unused in grammar

   FN
   INT
   FLOAT
   CHAR
   STRING
   ARRAY
   TABLE
   ALG
   WHEN
   END
   ANY
   RETURN
   IS
   DO
   IO
   IOFN
   LIST
   SL
   SR
   BOOL
   NOT
   TYPENAME
   INTEGER


Grammar

    0 $accept: pico $end

    1 pico: exprs

    2 exprs: expression '.'
    3      | pico expression '.'

    4 expression: symbolic
    5           | IDENTIFIER '=' expression ',' expression
    6           | IF term THEN term ELSE expression

    7 symbolic: log_or
    8         | log_or SYMBOL symbolic

    9 log_or: log_and
   10       | log_and OR log_or

   11 log_and: comparison
   12        | comparison AND log_and

   13 comparison: additive
   14           | additive comp_op comparison

   15 comp_op: '>'
   16        | '<'
   17        | LEQ
   18        | GEQ
   19        | EQ
   20        | NEQ

   21 additive: multiplicative
   22         | multiplicative '+' additive
   23         | multiplicative '-' additive

   24 multiplicative: unary
   25               | unary '*' multiplicative
   26               | unary '/' multiplicative

   27 unary: exponent
   28      | '!' unary
   29      | '-' unary

   30 exponent: call
   31         | call '^' exponent

   32 call: term
   33     | call '(' expression_list ')'

   34 expression_list: opt_expression
   35                | expression_list ',' opt_expression

   36 opt_expression: expression
   37               | /* empty */

   38 term: INT_LITERAL
   39     | FLOAT_LITERAL
   40     | CHAR_LITERAL
   41     | STRING_LITERAL
   42     | TRUE
   43     | FALSE
   44     | var
   45     | '{' expression '}'
   46     | '(' expression ')'

   47 var: IDENTIFIER
   48    | IDENTIFIER ':' IDENTIFIER
   49    | ANON_RECURSE


Terminals, with rules where they appear

$end (0) 0
'!' (33) 28
'(' (40) 33 46
')' (41) 33 46
'*' (42) 25
'+' (43) 22
',' (44) 5 35
'-' (45) 23 29
'.' (46) 2 3
'/' (47) 26
':' (58) 48
'<' (60) 16
'=' (61) 5
'>' (62) 15
'^' (94) 31
'{' (123) 45
'}' (125) 45
error (256)
FN (258)
INT (259)
FLOAT (260)
CHAR (261)
STRING (262)
ARRAY (263)
TABLE (264)
ALG (265)
WHEN (266)
END (267)
IF (268) 6
THEN (269) 6
ANY (270)
RETURN (271)
IS (272)
DO (273)
IO (274)
IOFN (275)
LIST (276)
SL (277)
SR (278)
BOOL (279)
TRUE (280) 42
FALSE (281) 43
OR (282) 10
AND (283) 12
NOT (284)
ELSE (285) 6
LEQ (286) 17
GEQ (287) 18
EQ (288) 19
NEQ (289) 20
IDENTIFIER (290) 5 47 48
SYMBOL (291) 8
ANON_RECURSE (292) 49
TYPENAME (293)
STRING_LITERAL (294) 41
FLOAT_LITERAL (295) 39
INT_LITERAL (296) 38
CHAR_LITERAL (297) 40
INTEGER (298)


Nonterminals, with rules where they appear

$accept (60)
    on left: 0
pico (61)
    on left: 1, on right: 0 3
exprs (62)
    on left: 2 3, on right: 1
expression (63)
    on left: 4 5 6, on right: 2 3 5 6 36 45 46
symbolic (64)
    on left: 7 8, on right: 4 8
log_or (65)
    on left: 9 10, on right: 7 8 10
log_and (66)
    on left: 11 12, on right: 9 10 12
comparison (67)
    on left: 13 14, on right: 11 12 14
comp_op (68)
    on left: 15 16 17 18 19 20, on right: 14
additive (69)
    on left: 21 22 23, on right: 13 14 22 23
multiplicative (70)
    on left: 24 25 26, on right: 21 22 23 25 26
unary (71)
    on left: 27 28 29, on right: 24 25 26 28 29
exponent (72)
    on left: 30 31, on right: 27 31
call (73)
    on left: 32 33, on right: 30 31 33
expression_list (74)
    on left: 34 35, on right: 33 35
opt_expression (75)
    on left: 36 37, on right: 34 35
term (76)
    on left: 38 39 40 41 42 43 44 45 46, on right: 6 32
var (77)
    on left: 47 48 49, on right: 44


State 0

    0 $accept: . pico $end
    1 pico: . exprs
    2 exprs: . expression '.'
    3      | . pico expression '.'
    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    pico            go to state 14
    exprs           go to state 15
    expression      go to state 16
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 1

    6 expression: IF . term THEN term ELSE expression
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    term  go to state 29
    var   go to state 27


State 2

   42 term: TRUE .

    $default  reduce using rule 42 (term)


State 3

   43 term: FALSE .

    $default  reduce using rule 43 (term)


State 4

    5 expression: IDENTIFIER . '=' expression ',' expression
   47 var: IDENTIFIER .  [OR, AND, LEQ, GEQ, EQ, NEQ, SYMBOL, '.', ',', '>', '<', '+', '-', '*', '/', '^', '(', ')', '}']
   48    | IDENTIFIER . ':' IDENTIFIER

    '='  shift, and go to state 30
    ':'  shift, and go to state 31

    $default  reduce using rule 47 (var)


State 5

   49 var: ANON_RECURSE .

    $default  reduce using rule 49 (var)


State 6

   41 term: STRING_LITERAL .

    $default  reduce using rule 41 (term)


State 7

   39 term: FLOAT_LITERAL .

    $default  reduce using rule 39 (term)


State 8

   38 term: INT_LITERAL .

    $default  reduce using rule 38 (term)


State 9

   40 term: CHAR_LITERAL .

    $default  reduce using rule 40 (term)


State 10

   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   29      | '-' . unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    unary     go to state 32
    exponent  go to state 24
    call      go to state 25
    term      go to state 26
    var       go to state 27


State 11

   27 unary: . exponent
   28      | . '!' unary
   28      | '!' . unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    unary     go to state 33
    exponent  go to state 24
    call      go to state 25
    term      go to state 26
    var       go to state 27


State 12

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   46     | '(' . expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    expression      go to state 34
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 13

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   45     | '{' . expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    expression      go to state 35
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 14

    0 $accept: pico . $end
    3 exprs: pico . expression '.'
    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    $end            shift, and go to state 36
    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    expression      go to state 37
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 15

    1 pico: exprs .

    $default  reduce using rule 1 (pico)


State 16

    2 exprs: expression . '.'

    '.'  shift, and go to state 38


State 17

    4 expression: symbolic .

    $default  reduce using rule 4 (expression)


State 18

    7 symbolic: log_or .  ['.', ',', ')', '}']
    8         | log_or . SYMBOL symbolic

    SYMBOL  shift, and go to state 39

    $default  reduce using rule 7 (symbolic)


State 19

    9 log_or: log_and .  [SYMBOL, '.', ',', ')', '}']
   10       | log_and . OR log_or

    OR  shift, and go to state 40

    $default  reduce using rule 9 (log_or)


State 20

   11 log_and: comparison .  [OR, SYMBOL, '.', ',', ')', '}']
   12        | comparison . AND log_and

    AND  shift, and go to state 41

    $default  reduce using rule 11 (log_and)


State 21

   13 comparison: additive .  [OR, AND, SYMBOL, '.', ',', ')', '}']
   14           | additive . comp_op comparison
   15 comp_op: . '>'
   16        | . '<'
   17        | . LEQ
   18        | . GEQ
   19        | . EQ
   20        | . NEQ

    LEQ  shift, and go to state 42
    GEQ  shift, and go to state 43
    EQ   shift, and go to state 44
    NEQ  shift, and go to state 45
    '>'  shift, and go to state 46
    '<'  shift, and go to state 47

    $default  reduce using rule 13 (comparison)

    comp_op  go to state 48


State 22

   21 additive: multiplicative .  [OR, AND, LEQ, GEQ, EQ, NEQ, SYMBOL, '.', ',', '>', '<', ')', '}']
   22         | multiplicative . '+' additive
   23         | multiplicative . '-' additive

    '+'  shift, and go to state 49
    '-'  shift, and go to state 50

    $default  reduce using rule 21 (additive)


State 23

   24 multiplicative: unary .  [OR, AND, LEQ, GEQ, EQ, NEQ, SYMBOL, '.', ',', '>', '<', '+', '-', ')', '}']
   25               | unary . '*' multiplicative
   26               | unary . '/' multiplicative

    '*'  shift, and go to state 51
    '/'  shift, and go to state 52

    $default  reduce using rule 24 (multiplicative)


State 24

   27 unary: exponent .

    $default  reduce using rule 27 (unary)


State 25

   30 exponent: call .  [OR, AND, LEQ, GEQ, EQ, NEQ, SYMBOL, '.', ',', '>', '<', '+', '-', '*', '/', ')', '}']
   31         | call . '^' exponent
   33 call: call . '(' expression_list ')'

    '^'  shift, and go to state 53
    '('  shift, and go to state 54

    $default  reduce using rule 30 (exponent)


State 26

   32 call: term .

    $default  reduce using rule 32 (call)


State 27

   44 term: var .

    $default  reduce using rule 44 (term)


State 28

   47 var: IDENTIFIER .  [THEN, OR, AND, ELSE, LEQ, GEQ, EQ, NEQ, SYMBOL, '.', ',', '>', '<', '+', '-', '*', '/', '^', '(', ')', '}']
   48    | IDENTIFIER . ':' IDENTIFIER

    ':'  shift, and go to state 31

    $default  reduce using rule 47 (var)


State 29

    6 expression: IF term . THEN term ELSE expression

    THEN  shift, and go to state 55


State 30

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    5           | IDENTIFIER '=' . expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    expression      go to state 56
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 31

   48 var: IDENTIFIER ':' . IDENTIFIER

    IDENTIFIER  shift, and go to state 57


State 32

   29 unary: '-' unary .

    $default  reduce using rule 29 (unary)


State 33

   28 unary: '!' unary .

    $default  reduce using rule 28 (unary)


State 34

   46 term: '(' expression . ')'

    ')'  shift, and go to state 58


State 35

   45 term: '{' expression . '}'

    '}'  shift, and go to state 59


State 36

    0 $accept: pico $end .

    $default  accept


State 37

    3 exprs: pico expression . '.'

    '.'  shift, and go to state 60


State 38

    2 exprs: expression '.' .

    $default  reduce using rule 2 (exprs)


State 39

    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    8         | log_or SYMBOL . symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    symbolic        go to state 61
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 40

    9 log_or: . log_and
   10       | . log_and OR log_or
   10       | log_and OR . log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    log_or          go to state 62
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 41

   11 log_and: . comparison
   12        | . comparison AND log_and
   12        | comparison AND . log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    log_and         go to state 63
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 42

   17 comp_op: LEQ .

    $default  reduce using rule 17 (comp_op)


State 43

   18 comp_op: GEQ .

    $default  reduce using rule 18 (comp_op)


State 44

   19 comp_op: EQ .

    $default  reduce using rule 19 (comp_op)


State 45

   20 comp_op: NEQ .

    $default  reduce using rule 20 (comp_op)


State 46

   15 comp_op: '>' .

    $default  reduce using rule 15 (comp_op)


State 47

   16 comp_op: '<' .

    $default  reduce using rule 16 (comp_op)


State 48

   13 comparison: . additive
   14           | . additive comp_op comparison
   14           | additive comp_op . comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    comparison      go to state 64
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 49

   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   22         | multiplicative '+' . additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    additive        go to state 65
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 50

   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   23         | multiplicative '-' . additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    additive        go to state 66
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 51

   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   25               | unary '*' . multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    multiplicative  go to state 67
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 52

   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   26               | unary '/' . multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    multiplicative  go to state 68
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 53

   30 exponent: . call
   31         | . call '^' exponent
   31         | call '^' . exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    exponent  go to state 69
    call      go to state 25
    term      go to state 26
    var       go to state 27


State 54

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   33     | call '(' . expression_list ')'
   34 expression_list: . opt_expression
   35                | . expression_list ',' opt_expression
   36 opt_expression: . expression
   37               | .  [',', ')']
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    $default  reduce using rule 37 (opt_expression)

    expression       go to state 70
    symbolic         go to state 17
    log_or           go to state 18
    log_and          go to state 19
    comparison       go to state 20
    additive         go to state 21
    multiplicative   go to state 22
    unary            go to state 23
    exponent         go to state 24
    call             go to state 25
    expression_list  go to state 71
    opt_expression   go to state 72
    term             go to state 26
    var              go to state 27


State 55

    6 expression: IF term THEN . term ELSE expression
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 28
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    term  go to state 73
    var   go to state 27


State 56

    5 expression: IDENTIFIER '=' expression . ',' expression

    ','  shift, and go to state 74


State 57

   48 var: IDENTIFIER ':' IDENTIFIER .

    $default  reduce using rule 48 (var)


State 58

   46 term: '(' expression ')' .

    $default  reduce using rule 46 (term)


State 59

   45 term: '{' expression '}' .

    $default  reduce using rule 45 (term)


State 60

    3 exprs: pico expression '.' .

    $default  reduce using rule 3 (exprs)


State 61

    8 symbolic: log_or SYMBOL symbolic .

    $default  reduce using rule 8 (symbolic)


State 62

   10 log_or: log_and OR log_or .

    $default  reduce using rule 10 (log_or)


State 63

   12 log_and: comparison AND log_and .

    $default  reduce using rule 12 (log_and)


State 64

   14 comparison: additive comp_op comparison .

    $default  reduce using rule 14 (comparison)


State 65

   22 additive: multiplicative '+' additive .

    $default  reduce using rule 22 (additive)


State 66

   23 additive: multiplicative '-' additive .

    $default  reduce using rule 23 (additive)


State 67

   25 multiplicative: unary '*' multiplicative .

    $default  reduce using rule 25 (multiplicative)


State 68

   26 multiplicative: unary '/' multiplicative .

    $default  reduce using rule 26 (multiplicative)


State 69

   31 exponent: call '^' exponent .

    $default  reduce using rule 31 (exponent)


State 70

   36 opt_expression: expression .

    $default  reduce using rule 36 (opt_expression)


State 71

   33 call: call '(' expression_list . ')'
   35 expression_list: expression_list . ',' opt_expression

    ','  shift, and go to state 75
    ')'  shift, and go to state 76


State 72

   34 expression_list: opt_expression .

    $default  reduce using rule 34 (expression_list)


State 73

    6 expression: IF term THEN term . ELSE expression

    ELSE  shift, and go to state 77


State 74

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    5           | IDENTIFIER '=' expression ',' . expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    expression      go to state 78
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 75

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   35 expression_list: expression_list ',' . opt_expression
   36 opt_expression: . expression
   37               | .  [',', ')']
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    $default  reduce using rule 37 (opt_expression)

    expression      go to state 70
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    opt_expression  go to state 79
    term            go to state 26
    var             go to state 27


State 76

   33 call: call '(' expression_list ')' .

    $default  reduce using rule 33 (call)


State 77

    4 expression: . symbolic
    5           | . IDENTIFIER '=' expression ',' expression
    6           | . IF term THEN term ELSE expression
    6           | IF term THEN term ELSE . expression
    7 symbolic: . log_or
    8         | . log_or SYMBOL symbolic
    9 log_or: . log_and
   10       | . log_and OR log_or
   11 log_and: . comparison
   12        | . comparison AND log_and
   13 comparison: . additive
   14           | . additive comp_op comparison
   21 additive: . multiplicative
   22         | . multiplicative '+' additive
   23         | . multiplicative '-' additive
   24 multiplicative: . unary
   25               | . unary '*' multiplicative
   26               | . unary '/' multiplicative
   27 unary: . exponent
   28      | . '!' unary
   29      | . '-' unary
   30 exponent: . call
   31         | . call '^' exponent
   32 call: . term
   33     | . call '(' expression_list ')'
   38 term: . INT_LITERAL
   39     | . FLOAT_LITERAL
   40     | . CHAR_LITERAL
   41     | . STRING_LITERAL
   42     | . TRUE
   43     | . FALSE
   44     | . var
   45     | . '{' expression '}'
   46     | . '(' expression ')'
   47 var: . IDENTIFIER
   48    | . IDENTIFIER ':' IDENTIFIER
   49    | . ANON_RECURSE

    IF              shift, and go to state 1
    TRUE            shift, and go to state 2
    FALSE           shift, and go to state 3
    IDENTIFIER      shift, and go to state 4
    ANON_RECURSE    shift, and go to state 5
    STRING_LITERAL  shift, and go to state 6
    FLOAT_LITERAL   shift, and go to state 7
    INT_LITERAL     shift, and go to state 8
    CHAR_LITERAL    shift, and go to state 9
    '-'             shift, and go to state 10
    '!'             shift, and go to state 11
    '('             shift, and go to state 12
    '{'             shift, and go to state 13

    expression      go to state 80
    symbolic        go to state 17
    log_or          go to state 18
    log_and         go to state 19
    comparison      go to state 20
    additive        go to state 21
    multiplicative  go to state 22
    unary           go to state 23
    exponent        go to state 24
    call            go to state 25
    term            go to state 26
    var             go to state 27


State 78

    5 expression: IDENTIFIER '=' expression ',' expression .

    $default  reduce using rule 5 (expression)


State 79

   35 expression_list: expression_list ',' opt_expression .

    $default  reduce using rule 35 (expression_list)


State 80

    6 expression: IF term THEN term ELSE expression .

    $default  reduce using rule 6 (expression)
