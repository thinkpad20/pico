foo = a + 1,
bar = 3 - 4 * 2 + 19, -- register a thunk with term (3-4*2+19)

baz = foo(bar), -- now baz = call (foo) (bar)

print(baz). -- now baz must be reduceuated!

<-- reduceuating baz:

need to reduceuate foo:

(a) + 1, a is unbound so foo is a function

pass in bar as an arg means:

temp_register(a, bar) -- temporarily add a -> bar rule

now baz = (bar) + 1

need to reduceuate bar

res = reduce(bar) -- res = 14
sym_update(bar, res) -- update the thunk the symbol table points to, now bar points to 14

reduce(baz)
(14) + 1 -> 15
sym_update(baz, res)

Note that we didn't update foo's entry here, because it's irreducible.

sym_cleartemps() -- removes a->bar rule

What if it was foo = (a = 14 * 6 + Int i, b = a - 3, b + i) ?

bar = foo(10)
print(bar)

temp_register(i, 10)
reduce(foo)
sym_add(a, 14 * 6)
sym_add(b, a - 3)
reduce(b + i)
   reduce(b) -> a - 3
      reduce(a) -> 14 * 6 + i = 84 + 10 -- update a's symbol table entry



-->